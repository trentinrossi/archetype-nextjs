# Next.js Application Archetype Guide

## Overview

This is a Next.js 15.5.3 application archetype with React 19, TypeScript 5, TailwindCSS v4, and Turbopack. It follows a modern component-based architecture pattern for building frontend applications with App Router and server components.

**Important**: This archetype is a **clean template** ready for implementation. The documentation uses generic examples (like 'items', 'products') to demonstrate patterns. When implementing features, you should should follow the established patterns without modifying the existing UI components, CSS, or core application structure.

## Project Structure

```text
archetype-nextjs/
├── eslint.config.mjs                    # ESLint configuration (flat config)
├── next.config.ts                       # Next.js configuration
├── package.json                         # Project dependencies and scripts
├── postcss.config.mjs                   # PostCSS configuration for TailwindCSS
├── tsconfig.json                        # TypeScript configuration
├── archetype.md                         # This archetype guide
├── public/                              # Static assets
│   ├── file.svg
│   ├── globe.svg
│   ├── next.svg
│   ├── vercel.svg
│   └── window.svg
└── src/
    ├── api/                             # API routes (Next.js API routes)
    |   ├── auth/                        # Example API routes for 'auth' feature
    |   |   └── login/
    |   |       └── route.ts              # POST login route
    |   ├── users/                       # Example API routes for 'users' feature
    |   |   ├── [id].ts                   # GET, PUT, DELETE user by ID
    |   |   ├── email/                   # Nested route for user by email
    |   |   |   └── [email].ts            # GET user by email
    |   |   └── index.ts                  # GET all users, POST new user
    │   └── items/                       # Example API routes for 'items' feature
    │       ├── [id].ts                   # GET, PUT, DELETE item by ID
    │       ├── name/                    # Nested route for item by name
    │       │   └── [name].ts             # GET item by name
    │       └── index.ts                  # GET all items, POST new item
    ├── app/                             # Next.js App Router directory
    │   ├── favicon.ico                  # Application favicon
    │   ├── globals.css                  # Global styles with TailwindCSS v4
    │   ├── layout.tsx                   # Root layout component
    │   └── page.tsx                     # Home page component
    ├── components/                      # Reusable UI components
    │   ├── ProtectedRoute.tsx           # Route protection component for authentication
    │   └── ui/                          # Base UI component library
    │       ├── Button.tsx               # Button component
    │       ├── Input.tsx                # Input component
    │       ├── Modal.tsx                # Modal component
    │       ├── Select.tsx               # Select component
    │       ├── Table.tsx                # Table component
    │       └── index.ts                 # Component exports
    ├── contexts/                        # React Context providers
    │   └── AuthContext.tsx              # Authentication context provider
    ├── lib/                             # Library utilities and helpers
    │   └── auth-middleware.ts           # Authentication middleware utilities
    ├── services/                        # API service layer
    │   └── authService.ts               # Authentication service
    └── types/                           # TypeScript type definitions
        └── auth.ts                      # Authentication type definitions
```

## Architecture Layers

### 1. App Layer (`/src/app`)

- **Purpose**: Next.js App Router for routing and layout management
- **Responsibilities**:
  - Define application routes and pages
  - Manage layouts and metadata
  - Handle server and client components
  - Configure global styles and fonts

**Example Structure:**

```tsx
// app/layout.tsx - Root Layout
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "NextJs Demo Application",
  description: "Generated by Wynxx System Modernization Team",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}

// app/page.tsx - Home Page
import Image from "next/image";
import Link from "next/link";

export default function Home() {
  return (
    <div className="font-sans grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20">
      <main className="flex flex-col gap-[32px] row-start-2 items-center sm:items-start">
        <div className="flex items-center gap-4">
          <Image
            className="dark:invert"
            src="/next.svg"
            alt="Next.js logo"
            width={180}
            height={38}
            priority
          />
          <div className="w-2 h-8 bg-primary"></div>
          <h1 className="text-2xl font-bold text-foreground">Next.js Archetype</h1>
        </div>
        
        <p className="text-center sm:text-left text-muted-foreground max-w-md">
          Welcome to the Next.js application archetype. A modern frontend template ready for your features.
        </p>

        <div className="flex gap-4 items-center flex-col sm:flex-row">
          <Link
            className="rounded-full border border-solid border-transparent transition-colors flex items-center justify-center bg-primary text-primary-foreground gap-2 hover:bg-primary/90 font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 sm:w-auto"
            href="/login"
          >
            Login
          </Link>
          <a
            className="rounded-full border border-solid border-border transition-colors flex items-center justify-center hover:bg-muted font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 w-full sm:w-auto md:w-[158px]"
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Documentation
          </a>
        </div>
      </main>
      <footer className="row-start-3 flex gap-[24px] flex-wrap items-center justify-center">
        <p className="text-sm text-muted-foreground">
          Next.js Archetype © 2025
        </p>
      </footer>
    </div>
  );
}


// app/items/page.tsx - Items Page
import { ItemTable } from '@/components/ui/Table';
import { itemService } from '@/services/itemService';

function ItemsPage() {
  const [items, setItems] = useState<Item[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const data = await itemService.getAllItems();
        setItems(data);
      } catch (error) {
        setError("Failed to fetch items");
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  if (loading) {
    return <div>Loading...</div>;
  }

  if (error) {
    return <div>{error}</div>;
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">Items Management</h1>
      <ItemTable data={items} />
    </div>
  );
}
```

### 2. Components Layer (`/src/components`)

- **Purpose**: Reusable UI components and component library
- **Responsibilities**:
  - Define reusable UI elements
  - Implement component logic and styling
  - Provide consistent design system
  - Handle component state and events

**Example Structure:**

```tsx
// components/ui/Button.tsx
import { ButtonHTMLAttributes, forwardRef } from 'react';

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'destructive' | 'outline';
  size?: 'sm' | 'md' | 'lg';
}

const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ variant = 'primary', size = 'md', className = '', ...props }, ref) => {
    const baseClasses = 'inline-flex items-center justify-center rounded-md font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50';
    
    const variants = {
      primary: 'bg-primary text-primary-foreground hover:bg-primary/90 focus-visible:ring-primary',
      secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80 focus-visible:ring-secondary',
      destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90 focus-visible:ring-destructive',
      outline: 'border border-border bg-background hover:bg-muted text-foreground focus-visible:ring-primary',
    };
    
    const sizes = {
      sm: 'h-8 px-3 text-sm',
      md: 'h-10 px-4',
      lg: 'h-12 px-6 text-lg',
    };
    
    const classes = `${baseClasses} ${variants[variant]} ${sizes[size]} ${className}`;
    
    return (
      <button ref={ref} className={classes} {...props} />
    );
  }
);

Button.displayName = 'Button';

export { Button };

// components/ui/Input.tsx
import { InputHTMLAttributes, forwardRef } from 'react';

interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  error?: string;
}

const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ label, error, className = '', ...props }, ref) => {
    return (
      <div className="w-full">
        {label && (
          <label className="block text-sm font-medium mb-2">
            {label}
          </label>
        )}
        <input
          ref={ref}
          className={`flex h-10 w-full rounded-md border border-border bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 ${error ? 'border-destructive' : ''} ${className}`}
          {...props}
        />
        {error && (
          <p className="text-sm text-destructive mt-1">{error}</p>
        )}
      </div>
    );
  }
);

Input.displayName = 'Input';

export { Input };

// components/ProtectedRoute.tsx
'use client';

import { useAuth } from '@/contexts/AuthContext';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';

export default function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { isAuthenticated, loading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!loading && !isAuthenticated) {
      router.push('/login');
    }
  }, [isAuthenticated, loading, router]);

  if (loading) {
    return <div>Checking authentication...</div>;
  }

  if (!isAuthenticated) {
    return <div>Redirecting to login...</div>;
  }

  return <>{children}</>;
}
```

### 3. Contexts Layer (`/src/contexts`)

- **Purpose**: React Context providers for global state management
- **Responsibilities**:
  - Manage application-wide state
  - Provide authentication state and methods
  - Handle user session management
  - Coordinate between services and components

**Example Structure:**

```tsx
// contexts/AuthContext.tsx
'use client';

import React, { createContext, useContext, useState, useEffect } from 'react';
import { authService } from '@/services/authService';
import { UserResponse, UserCreate } from '@/types/auth';

interface AuthContextType {
  isAuthenticated: boolean;
  user: UserResponse | null;
  loading: boolean;
  login: (username: string, password: string) => Promise<boolean>;
  register: (userData: UserCreate) => Promise<boolean>;
  logout: () => void;
  refreshToken: () => Promise<boolean>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [user, setUser] = useState<UserResponse | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const initializeAuth = async () => {
      const token = authService.getToken();
      const savedUserData = authService.getUser();

      if (token && savedUserData) {
        try {
          const currentUser = await authService.getCurrentUser();
          setUser(currentUser);
          setIsAuthenticated(true);
          authService.setUser(currentUser);
        } catch (error) {
          console.error('Token validation failed:', error);
          authService.removeToken();
          setUser(null);
          setIsAuthenticated(false);
        }
      }
      setLoading(false);
    };

    initializeAuth();
  }, []);

  const login = async (username: string, password: string): Promise<boolean> => {
    try {
      setLoading(true);
      const tokenResponse = await authService.login({ username, password });
      authService.setToken(tokenResponse.access_token);

      const userResponse = await authService.getCurrentUser();
      authService.setUser(userResponse);

      setUser(userResponse);
      setIsAuthenticated(true);
      return true;
    } catch (error) {
      console.error('Login failed:', error);
      return false;
    } finally {
      setLoading(false);
    }
  };

  const logout = () => {
    authService.removeToken();
    setUser(null);
    setIsAuthenticated(false);
  };

  return (
    <AuthContext.Provider value={{ 
      isAuthenticated, 
      user, 
      loading, 
      login, 
      logout, 
      refreshToken 
    }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
```

### 4. Library Layer (`/src/lib`)

- **Purpose**: Utility functions and middleware helpers
- **Responsibilities**:
  - Provide reusable utility functions
  - Handle authentication middleware logic
  - Forward requests with proper headers
  - Process API responses

**Example Structure:**

```typescript
// lib/auth-middleware.ts
import { NextRequest } from 'next/server';

const API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:8000';

export function getAuthHeaders(request: NextRequest): Record<string, string> {
  const authorization = request.headers.get('authorization');
  
  return {
    'Content-Type': 'application/json',
    ...(authorization && { Authorization: authorization }),
  };
}

export async function forwardAuthRequest(
  endpoint: string,
  method: string,
  request: NextRequest,
  body?: unknown
): Promise<Response> {
  const headers = getAuthHeaders(request);
  
  const fetchOptions: RequestInit = {
    method,
    headers,
  };
  
  if (body) {
    fetchOptions.body = JSON.stringify(body);
  }
  
  const response = await fetch(`${API_BASE_URL}${endpoint}`, fetchOptions);
  
  return response;
}

export async function handleAuthApiResponse(response: Response) {
  try {
    const data = await response.json();
    return { data, status: response.status, ok: response.ok };
  } catch (error) {
    console.error('Failed to parse API response:', error);
    return {
      data: { error: 'Failed to parse response' },
      status: 500,
      ok: false
    };
  }
}
```

### 5. API Layer (`/src/api`)

- **Purpose**: API routes and backend communication
- **Responsibilities**:
  - Define API endpoints and request methods
  - Implement data fetching logic
  - Handle API responses and errors

**Example Structure:**

```jsx
import { NextRequest, NextResponse } from 'next/server';
import { forwardAuthRequest, handleAuthApiResponse } from '@/lib/auth-middleware';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    const response = await forwardAuthRequest(
      '/api/v1/auth/login',
      'POST',
      request,
      body
    );
    
    const result = await handleAuthApiResponse(response);
    
    return NextResponse.json(result.data, { status: result.status });
  } catch (error) {
    console.error('Error in login API route:', error);
    return NextResponse.json(
      { error: 'Failed to process login request' },
      { status: 500 }
    );
  }
}
```

```typescript
// api/items/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { forwardAuthRequest, handleAuthApiResponse } from '@/lib/auth-middleware';

interface RouteParams {
  params: Promise<{ id: string }>;
}

export async function GET(
  request: NextRequest,
  context: RouteParams
) {
  try {
    const { id } = await context.params;
    
    const response = await forwardAuthRequest(
      `/api/v1/items/${id}`,
      'GET',
      request
    );
    
    const result = await handleAuthApiResponse(response);
    
    return NextResponse.json(result.data, { status: result.status });
  } catch (error) {
    console.error('Error fetching items:', error);
    return NextResponse.json(
      { error: 'Failed to fetch items' },
      { status: 500 }
    );
  }
}

// Another methods here (PUT, DELETE, etc.)
```

### 6. Services Layer (`/src/services`)

- **Purpose**: API communication and data fetching
- **Responsibilities**:
  - Handle HTTP requests to backend APIs
  - Implement data fetching strategies
  - Manage API error handling
  - Provide data transformation

**Example Structure:**

```typescript
// services/itemService.ts
import { Item } from '@/types/item';

const API_BASE_URL = '/api';

class ItemService {
  private async handleResponse<T>(response: Response): Promise<T> {
    if (!response.ok) {
      const errorData: APIError = await response.json().catch(() => ({}));
      throw new Error(
        errorData.detail?.[0]?.msg || 
        `HTTP ${response.status}: ${response.statusText}`
      );
    }
    return response.json();
  }

  async listItems(): Promise<Item[]> {
    const response = await fetch(`${API_BASE_URL}/items`, {
      headers: this.getAuthHeaders(),
    });
    const data = await this.handleResponse<Record<string, unknown>>(response);
    
    // Handle the response format based on API behavior
    if (Array.isArray(data)) {
      return data as Item[];
    } else if (data.items && Array.isArray(data.items)) {
      return data.items as Item[];
    } else {
      return [];
    }
  }

  async getItemById(id: string): Promise<Item> {
    const response = await fetch(`${API_BASE_URL}/items/${id}`, {
      headers: this.getAuthHeaders(),
    });
    return this.handleResponse<Item>(response);
  }

  async getItemByName(name: string): Promise<Item> {
    const response = await fetch(`${API_BASE_URL}/items/name/${name}`, {
      headers: this.getAuthHeaders(),
    });
    return this.handleResponse<Item>(response);
  }

  async createItem(item: Omit<Item, 'id'>): Promise<Item> {
    const response = await fetch(`${API_BASE_URL}/items`, {
      method: 'POST',
      headers: this.getAuthHeaders(),
      body: JSON.stringify(item),
    });
    return this.handleResponse<Item>(response);
  }

  async updateItem(id: string, item: Omit<Item, 'id'>): Promise<Item> {
    const response = await fetch(`${API_BASE_URL}/items/${id}`, {
      method: 'PUT',
      headers: this.getAuthHeaders(),
      body: JSON.stringify(item),
    });
    return this.handleResponse<Item>(response);
  }

  async deleteItem(id: string): Promise<void> {
    const response = await fetch(`${API_BASE_URL}/items/${id}`, {
      method: 'DELETE',
      headers: this.getAuthHeaders(),
    });
    await this.handleResponse<void>(response);
  }
}

export const itemService = new ItemService();

// services/authService.ts
import { Token, UserCreate, UserLogin, UserResponse } from "@/types/auth";

const API_BASE_URL = '/api';

class AuthService {
  private isRefreshing = false;
  private refreshSubscribers: Array<(token: string) => void> = [];

  private getAuthHeaders(): Record<string, string> {
    const token = localStorage.getItem('access_token');
    return {
      'Content-Type': 'application/json',
      ...(token && { Authorization: `Bearer ${token}` }),
    };
  }

  async login(credentials: UserLogin): Promise<Token> {
    const response = await fetch(`${API_BASE_URL}/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(credentials),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.detail || 'Login failed');
    }

    return response.json();
  }

  async register(userData: UserCreate): Promise<UserResponse> {
    const response = await fetch(`${API_BASE_URL}/auth/register`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.detail || 'Registration failed');
    }

    return response.json();
  }

  async getCurrentUser(): Promise<UserResponse> {
    const response = await fetch(`${API_BASE_URL}/auth/me`, {
      method: 'GET',
      headers: this.getAuthHeaders(),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.detail || 'Failed to get user info');
    }

    return response.json();
  }

  async refreshToken(): Promise<Token> {
    const response = await fetch(`${API_BASE_URL}/auth/refresh`, {
      method: 'POST',
      headers: this.getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error('Token refresh failed');
    }

    return response.json();
  }

  // Token management helpers
  setToken(token: string): void {
    localStorage.setItem('access_token', token);
  }

  getToken(): string | null {
    return localStorage.getItem('access_token');
  }

  removeToken(): void {
    localStorage.removeItem('access_token');
    localStorage.removeItem('user');
  }

  setUser(userResponse: UserResponse): void {
    localStorage.setItem('user', JSON.stringify(userResponse.user));
  }

  getUser(): UserResponse['user'] | null {
    const userStr = localStorage.getItem('user');
    if (!userStr) return null;
    
    try {
      return JSON.parse(userStr);
    } catch {
      localStorage.removeItem('user');
      return null;
    }
  }
}

export const authService = new AuthService();
```

### 7. Types Layer (`/src/types`)

- **Purpose**: TypeScript type definitions and interfaces
- **Responsibilities**:
  - Define data models and interfaces
  - Provide type safety across the application
  - Document API contracts
  - Enable better IDE support

**Example Structure:**

```typescript
// types/item.ts
export interface Item {
  id: string;
  name: string;
  description: string;
  category: string;
  status: 'active' | 'inactive';
  createdAt: string;
  updatedAt: string;
}

// types/auth.ts
export interface UserLogin {
  username: string;
  password: string;
}

export interface UserCreate {
  username: string;
  email: string;
  password: string;
  full_name?: string;
}

export interface Token {
  access_token: string;
  token_type: string;
}

export interface UserResponse {
  message: string;
  user: {
    id: string;
    username: string;
    email: string;
    full_name?: string;
    role: string;
    is_active: boolean;
    created_at: string;
    updated_at: string;
  }
}

export interface HTTPValidationError {
  detail: Array<{
    loc: Array<string | number>;
    msg: string;
    type: string;
  }>;
}
```

## Getting Started

- Uses strict mode
- ES2017 target
- Bundler module resolution
- Path aliasing: `@/*` maps to `./src/*`

### TailwindCSS v4 Configuration

- Uses `@import "tailwindcss"` syntax (not v3)
- PostCSS integration via `@tailwindcss/postcss`
- Custom CSS variables for theming

## Development Guidelines

### Important: Clean Template

This archetype is provided as a **clean template** ready for feature implementation. The documentation uses generic examples (like 'items', 'products') to demonstrate the established patterns. When implementing new features, you should:

- **Use the existing UI components** (`Button`, `Input`, `Modal`, `Select`, `Table`) without modification
- **Keep the existing CSS and styling** intact
- **Follow the established layer structure** for new features
- **Only add new files** in the appropriate directories

### Implementing a New Feature (e.g., 'Products')

To implement a new feature, follow these **4 steps exactly** and **do not modify** existing application parts:

#### Step 1: Add New Types (`/src/types`)

#### Step 2: Add New API routes (`/src/api`)

#### Step 3: Add New Service (`/src/services`)

#### Step 4: Add New Page (`/src/app/products`)

### What NOT to Modify

When implementing new features, **DO NOT** change:

- ❌ **UI Components** (`/src/components/ui/`) - These are reusable across all features
- ❌ **CSS Files** (`globals.css`, TailwindCSS configuration) - Styling is already configured
- ❌ **Root Layout** (`app/layout.tsx`) - Global layout should remain unchanged
- ❌ **Configuration Files** (`next.config.ts`, `tsconfig.json`, etc.) - Core setup is complete
- ❌ **Existing Features** - This is a clean template with no existing feature implementations

### What TO Add/Modify

When implementing new features, **ONLY**:

- ✅ **Add new type files** in `/src/types/`
- ✅ **Add new API route files** in `/src/api/`
- ✅ **Add new service files** in `/src/services/`
- ✅ **Add new page directories** in `/src/app/`

### File Naming Conventions

- **Components**: PascalCase (e.g., `Button.tsx`, `ItemCard.tsx`)
- **Pages**: lowercase (e.g., `page.tsx`, `layout.tsx`, `loading.tsx`)
- **Services**: camelCase (e.g., `itemService.ts`, `apiClient.ts`)
- **Types**: camelCase (e.g., `item.ts`, `apiTypes.ts`)
- **Utilities**: camelCase (e.g., `formatDate.ts`, `validation.ts`)
- **API Routes**: lowercase (e.g., `route.ts`, `[id].ts`)

### Naming Conventions

- **Components**: PascalCase (e.g., `Button`, `ItemCard`, `ProductTable`)
- **Files**: kebab-case or PascalCase (e.g., `item-service.ts`, `ItemService.ts`)
- **Variables**: camelCase (e.g., `itemData`, `isLoading`, `handleClick`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `API_BASE_URL`, `DEFAULT_PAGE_SIZE`)
- **Types/Interfaces**: PascalCase (e.g., `Item`, `ApiResponse`, `CreateItemData`)
- **Props Interfaces**: PascalCase with "Props" suffix (e.g., `ButtonProps`, `ItemCardProps`)
- **Event Handlers**: "handle" prefix (e.g., `handleClick`, `handleSubmit`, `handleChange`)

### Standard Patterns

- **Server Components**: Default for pages and layouts (no 'use client')
- **Client Components**: Use `'use client'` directive when needed
- **Async Pages**: Use `async function` for server components with data fetching
- **Error Handling**: Use `error.tsx` and `not-found.tsx` for route-level errors
- **Loading States**: Use `loading.tsx` for route-level loading UI
- **Layouts**: Use `layout.tsx` for shared UI between routes
- **Metadata**: Export `metadata` object or `generateMetadata` function

## Available Dependencies

- **Next.js 15.5.3**: React framework with App Router
- **React 19.1.0**: UI library with concurrent features
- **TypeScript 5**: Type safety and enhanced developer experience
- **TailwindCSS v4**: Utility-first CSS framework (alpha version)
- **Turbopack**: Fast bundler for development and builds
- **ESLint 9**: Code linting with flat config format
- **PostCSS**: CSS processing for TailwindCSS integration
- **MUI (Material-UI)**: Component library for React

### Key Technology Features

- **App Router**: File-system based routing with layouts and nested routes
- **Server Components**: React components that render on the server
- **Turbopack**: Faster alternative to Webpack for builds and dev server
- **TailwindCSS v4**: Latest version with `@import "tailwindcss"` syntax
- **TypeScript Path Mapping**: `@/*` alias for clean imports
- **Font Optimization**: Automatic optimization of Google Fonts (Geist)
- **Image Optimization**: Built-in Next.js Image component for performance
